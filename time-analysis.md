Эту статью написал мой хороший знакомый Слава Муравьев (https://vk.com/slamur), многому меня научивший

Часто написать программу, считающую ответ на задачу, не так уж и сложно.
Намного сложнее оказывается написать программу, считающую ответ, которая укладывается в ограничения по времени работы (Time Limit) и по используемой памяти (Memory Limit).

Давайте научимся оценивать время и память, необходимые вашему алгоритму для решения задачи.

#### Временная оценка.

Самый частый способ оценки времени работы вашей программы &mdash; оценка количества простых операций. 
В настоящее время используется приблизительная оценка, что за 1 секунду выполняется порядка 10^8 операций.

Нас не интересует точное количество операций, нас интересует лишь порядок. В идеале порядок количества операций должен быть на 1-2 порядка меньше максимума &mdash; тогда вам не придется думать о более точной оценке, и так будет понятно, что работает быстро. С другой стороны очевидно, что если программа выполняет порядка 10^10 операций, то в секунду она не уложится никак, да и в 2 секунды тоже) (здесь и далее мы будем рассматривать только работу на тестах, на которых программа выполняется максимально возможное время &mdash; оценка по худшему случаю).

Обозначим за T(N) &mdash; количество операций алгоритма, который принимает на вход вектор параметров N &mdash; N1, N2, ..., NK.
Предположим, что мы также знаем функцию F(N), что T(N) <= F(N) * C для любых N, где C &mdash; какая-то независящая от N константа.
Введем для такого случая обозначение, что T(N) = O(F(N)) &mdash; "O большое". Данное обозначение взято из высшей математики, а не из головы придумано)

Очевидно, что для одной T(N) существует бесконечно много F(N), что T(N) = O(F(N)).
Выберем те функции F1(N), F2(N), ..., FM(N), что 

	1. T(N) = O(F1(N)) = O(F2(N)) = ... = O(FM(N))
	2. F1(N) = O(T(N)), F2(N) = O(T(N)), ..., FM(N) = O(T(N)).
	
Пример:

	T(N) = 3 * N^2 - 2.	
	F1(N) = 5 * N^2, F2(N) = N^2 / 2, F3(N) = N^2 - N, ...
	
Заметим, что эти функции будут отличаться только линейными коэффициентами при слагаемых. Выберем среди данных функций F(N), такую что линейные коэффициенты при слагаемых старших порядков будут равны 1, при остальных &mdash; 0.
Для примера выше подходящей функцией будет F(N) = N^2: 
	
	- (3 * N^2 - 2) = O(N^2);
	- (N^2) = O(3 * N^2 - 2);
	- Коэффициент при слагаемом старшего порядка N^2 = 1.
	
Назовем такую функцию F(N) асимптотикой алгоритма с количеством операций T(N).
Теперь, чтобы оценить время работы программу, нам достаточно оценить ее асимптотику и, подставив в нее значения параметров на макс. тесте, выяснить порядок максимального числа операций.

Рассмотрим асимптотики, с помощью комбинации которых можно задать асимптотику практически любой программы:

	1. O(1) - простейшая операция - +, *, обращение по индексу к массиву и так далее - вообще не зависит от N.
	2. O(logN) - логарифм от N. Растет очень медленно. Основание логарифма не пишут, так как log_a(b) = log_c(b) / log_c(a), где 1 / log_c(a) - константа, не зависящая от b.
	3. O(N^k) - полиномиальная зависимость.
	4. O(a^N) - экспоненциальная зависимость. Здесь число a имеет значение, так как при переходе от a^n к b^n появляется коэффициент (a / b) ^ n, зависящий от n.
	5. O(N!) - факториал от N - очень быстро растет, но и решения с такой асимптотикой бывают.
	
Распишем частные случаи асимптотик и примерные значения N, при которых такая асимптотика еще позволит вам уложиться в 1 секунду:

	1. O(1) - любое N;
	2. O(logN) - любое N, влезающее в стандартные типы данных - слишком медленно растет :D
	3. O(N^(1 / 2)), O(N^(1 / 3)) - квадратный и кубический корни из N - растет медленно, но растет - 10^15-10^16 для квадратного корня и 10^18 для кубического;
	4. O(N) - "линия" - 10^7 - 10^8;
	5. O(N * logN) - "Н лог Н" - 10^5 - 10^6 (зависит от основания логарифма и опущенной константы).
	6. O(N * sqrt(N)) - 10^5.
	7. O(N^2) - "квадрат" - 10^4;
	8. O(N^3) - "куб" - 300 - 500;
	9. O(2^N), O(N * 2^N) - 20 - 24 (при 23-24 на грани).
	10. O(3^N) - примерно 14-16.
	11. O(1.5 ^ N) - 1.5 - приближение числа (1 + sqrt(5)) / 2 - это скорость роста значений чисел Фибоначчи.
	
Рассмотрим несколько частных примеров вычисления асимптотики:

	1. Последовательное выполнение алгоритмов.
	
		function T(N) {
			F(N);
			G(N);
		}	
	
В таком случае асимптотика T(N) будет равна O(F(N)) = O(G(N)) = O(F(N) + G(N)).
	
	2. Циклическое выполнение какого-либо алгоритма.
	
		for (int i = 0; i < M; ++i) {
			F(N);
		}
		
Проводя аналогии с предыдущим примером, здесь мы M раз выполняем алгоритм с асимптотикой O(F(N)), итого O(M) * O(F(N)) = O(M * F(N)).
	
	3. Циклическое уменьшение/увеличение величины в A раз.
	
		function F(N) {
			result = 0;
			while (N > 0) {
				N /= A;
			}
			
			return result;
		}
		
Здесь result будет равно минимальной степени A, при которой A^(result &mdash; 1) < N <= A^(result), откуда result = log_A(N) и асимптотика F(N) = O(result) = O(logN).
	
Для закрепления материала предлагаю вам придумать алгоритмы решения следующих задач и оценить их асимптотику:

	1. Найти сумму элементов массива A длины N.
	2. Найти максимум, минимум в массиве A длины N, найти и максимум, и минимум одновременно.
	3. Найти количества цифр в числе.
	4. Найти точку M - центр отрезка AB по координатам точек A и B.
	5. Найти индекс строки матрицы A размера NxM с минимальной суммой.
	6. Сравнить лексикографически (в алфавитном порядке) две строки S1 и S2.
	
#### Оценка памяти.

Количество памяти, используемой программой, оценить попроще &mdash; достаточно оценить общую память, занятую всеми значениями, используемыми в вашей программе.
В основном, много значений хранится в 
	
	- Многомерных массивах
	- В структурах, где элемент хранит ссылку на несколько других элементов структуры.
	
Оценивается для них одинаково &mdash; оценивается максимальное число элементов в массиве/структуре и умножается на размер элемента в байтах.

Пример:

	int[][][] a = new int[n][m][];
	for (int i = 0; i < n; ++i) {
		for (int j = 0; j < m; ++j) {
			a[i][j] = new int[j+1];
		}
	}
	
В таком случае в массив занимает N * (1 + 2 + ... + M) * sizeof(int) = N * M * (M + 1) / 2 * sizeof(int) = O(N * M^2 * sizeof(int)) памяти.
